<style>
  .force-graph {
    width: 100%;
    height: 600px;
  }
  .node-popover {
    position: absolute;
    background: hsla(193, 90%, 96%, 0.9);
    border-radius: 4px;
    padding: 10px;
    font-size: 14px;
    font-family: var(--font-sans);
    font-style: normal;
    pointer-events: none;
    max-width: 300px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }
  .node-popover img {
    max-width: 100%;
    height: auto;
    margin-bottom: 5px;
  }
</style>

<div id="2d-graph" class="force-graph"></div>
<div id="node-popover" class="node-popover"></div>

<!--
https://github.com/vasturiano/force-graph
-->
<script src="https://unpkg.com/force-graph"></script>

<script type="module">
  const data = {{ graph | tojson | safe }};
  const animation_speed = 150;

  const colorFromType = (type) => {
    switch (type) {
      case "concept":
        return "{{ colors.concept_dark }}";
      case "note":
        return "{{ colors.doc_dark }}";
      case "resource":
        return "{{ colors.resource_dark }}";
      default:
        return "{{ colors.white_dark }}";
    }
  };

  function wrapText(text, maxLineLength) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';

    words.forEach(word => {
      if ((currentLine + word).length <= maxLineLength) {
        currentLine += (currentLine ? ' ' : '') + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    });
    lines.push(currentLine);

    return lines.join('\n');
  }

  function truncate(description, maxLength = 200) {
    if (description && description.length > maxLength) {
      return description.slice(0, maxLength).trim() + ' â€¦';
    }
    return description;
  }

  const graphContainer = document.getElementById('2d-graph');
  const Graph = new ForceGraph(graphContainer)
    .graphData(data)
    .nodeColor(node => colorFromType(node.type))
    .linkColor(() => "{{ colors.link_light }}")
    .nodeCanvasObject((node, ctx, globalScale) => {
      const label = node.title || node.id;
      const fontSize = 14/globalScale;
      ctx.font = `${fontSize}px Sans-Serif`;
      const textWidth = ctx.measureText(label).width;
      const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.1); // some padding

      // Draw background rectangle
      // Using a semi-transparent white background like the example
      // Alternatively, could use colorFromType(node.type) with some transparency
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);

      // Draw text label
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = colorFromType(node.type); // Use node type color for text
      ctx.fillText(label, node.x, node.y);

      node.__bckgDimensions = bckgDimensions; // Store for pointer area interaction
    })
    .nodePointerAreaPaint((node, color, ctx) => {
      // Define the pointer area based on the background rectangle
      ctx.fillStyle = color; // color is managed by the library for hover/click indication
      const bckgDimensions = node.__bckgDimensions;
      bckgDimensions && ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
    })
    .onNodeHover((node, prevNode) => {
      const popover = document.getElementById('node-popover');
      if (node) {
        const { title, description, thumbnail_url } = node;
        let content = "";
        if (thumbnail_url) {
          content += `<img src="${thumbnail_url}" alt="${title}">`;
        }
        content += `<h2>${title}</h2>`;
        if (description) {
          content += `<p>${truncate(description)}</p>`;
        }
        popover.innerHTML = content;
        popover.style.display = 'block';

        // Calculate popover position relative to the node
        const graphRect = graphContainer.getBoundingClientRect();
        const x = node.x * Graph.zoom() + graphRect.left + 20; // 20px offset to the right
        let y = node.y * Graph.zoom() + graphRect.top;

        // Ensure the popover doesn't extend below the bottom of the screen
        const popoverHeight = popover.offsetHeight;
        const maxY = window.innerHeight - popoverHeight - 20; // 20px margin from bottom
        y = Math.min(y, maxY);

        popover.style.left = `${x}px`;
        popover.style.top = `${y}px`;

        setTimeout(() => {
          popover.style.opacity = '1';
        }, 0);
      } else {
        popover.style.opacity = '0';
        setTimeout(() => {
          popover.style.display = 'none';
        }, animation_speed);
      }
    })
    .onNodeClick((node, event) => {
      if (node.url) {
        window.open(node.url, '_blank');
      }
    });

  // Spread nodes a little wider
  // Graph.d3Force("charge").strength(-120);
</script>
